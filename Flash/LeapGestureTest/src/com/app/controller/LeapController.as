// com.adam.utils.LeapController// Adam Riggs//package com.app.controller{	import com.adam.events.MuleEvent;	import com.adam.utils.Utils;	import com.leapmotion.leap.CircleGesture;	import com.leapmotion.leap.Finger;	import com.leapmotion.leap.Frame;	import com.leapmotion.leap.Gesture;	import com.leapmotion.leap.Hand;	import com.leapmotion.leap.KeyTapGesture;	import com.leapmotion.leap.LeapMotion;	import com.leapmotion.leap.Pointable;	import com.leapmotion.leap.ScreenTapGesture;	import com.leapmotion.leap.SwipeGesture;	import com.leapmotion.leap.Tool;	import com.leapmotion.leap.Vector3;	import com.leapmotion.leap.events.LeapEvent;	import com.leapmotion.leap.util.LeapMath;		import com.greensock.TweenNano;		import flash.utils.getTimer;
		public class LeapController {				//vars		protected var _active:Boolean;		protected var _swipeLeft:Boolean;		protected var _swipeRight:Boolean;		protected var _gestureStart:Boolean;		protected var _gestureDuration:Number;				protected var _palmVelocityThreshold:int;						//objects		private var utils:Utils=Utils.instance;		private var _leap:LeapMotion;		protected var _frame:Frame;		protected var _hands:Vector.<Hand>;		protected var _fingers:Vector.<Finger>;		protected var _tools:Vector.<Tool>;		protected var _pointables:Vector.<Pointable>;		protected var _gestures:Vector.<Gesture>;				protected var _swipe:SwipeGesture;				//const		public static const NAME:String="leapController";		public const RETURNTYPE:String=NAME;				public static const SWIPE_RIGHT:String="swiperight";		public static const SWIPE_LEFT:String="swipeleft";				/** Storage for the singleton instance. */		private static const _instance:LeapController = new LeapController(LeapControllerLock);				public function LeapController(lock:Class){			if (lock != LeapControllerLock)			{				throw new Error("Invalid LeapController access.  Use LeapController.instance instead.");			} else {				init();			}		}		//*****Initialization Routines				public function init():void{			debug("init()");						initVars();			initEvents();			initObjs();		}				private function initVars():void{			_active=false;						_palmVelocityThreshold=1000;			_gestureDuration=.2;		}				private function initEvents():void{			//utils.em.listen(NAME, onLeapController);		}				private function initObjs():void{			_leap=new LeapMotion();			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_INIT, onInit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_CONNECTED, onConnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_DISCONNECTED, onDisconnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_EXIT, onExit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_FRAME, onFrame );			//			_leap.controller.enableGesture( Gesture.TYPE_CIRCLE );//			_leap.controller.enableGesture( Gesture.TYPE_KEY_TAP );//			_leap.controller.enableGesture( Gesture.TYPE_SCREEN_TAP );//			_leap.controller.enableGesture( Gesture.TYPE_SWIPE );		}		//*****Core Functionality				protected function endGesture():void{			debug("endGesture()");			_gestureStart=false;		}				public function getSwipeLeft():Boolean{			if(_swipeLeft){				_swipeLeft=false;				return true;			}			return false;		}				public function getSwipeRight():Boolean{			if(_swipeRight){				_swipeRight=false;				return true;			}			return false;		}		//*****Event Handlers								private function onInit( event:LeapEvent ):void{			debug( "Initialized" );			_active=false;		}				private function onConnect( event:LeapEvent ):void{			debug( "Connected" );			_active=true;		}				private function onDisconnect( event:LeapEvent ):void{			debug( "Disconnected" );			_active=false;		}				private function onExit( event:LeapEvent ):void{			debug( "Exited" );			_active=false;		}				private function onFrame( event:LeapEvent ):void		{			//debug("onFrame");			// Get the most recent _frame and report some basic information			_frame = event.frame;			_hands = _frame.hands;			_fingers = _frame.fingers;			_tools=_frame.tools;			_pointables=_frame.pointables;			_gestures=_frame._gestures;						for each(var finger:Finger in _frame.fingers){				if(finger.tipVelocity.x>100 || finger.tipVelocity.x<100){					//debug("finger.tipVelocity.x=="+finger.tipVelocity.x);				}				if(finger.tipVelocity.y>100 || finger.tipVelocity.y<100){					//debug("finger.tipVelocity.y=="+finger.tipVelocity.y);				}				if(finger.tipVelocity.z>100 || finger.tipVelocity.z<100){					//debug("finger.tipVelocity.z=="+finger.tipVelocity.z);				}				//debug("*****");			}									for each(var hand:Hand in event.frame.hands)			{				//debug("palmVelocity.x=="+hand.palmVelocity.x);				if(hand.fingers.length == 1)				{					//debug("palmVelocity.x=="+hand.palmVelocity.x);					if(hand.palmVelocity.x > _palmVelocityThreshold && !_gestureStart)					{						debug("right");						_swipeRight=true;						_gestureStart=true;						//utils.em.dispatch(NAME, {sender:NAME, type:SWIPE_RIGHT});						TweenNano.delayedCall(_gestureDuration,endGesture);											}					else if(hand.palmVelocity.x < -_palmVelocityThreshold && !_gestureStart)					{						debug("left");						_swipeLeft=true;						_gestureStart=true;						//utils.em.dispatch(NAME, {sender:NAME, type:SWIPE_LEFT});						TweenNano.delayedCall(_gestureDuration,endGesture);											}				}			}						if(_gestures.length>0){								switch(_gestures[0].type){										case 0:						debug("Gesture.STATE_INVALID");						break;										case 1:						debug("Gesture.STATE_START");						break;										case 2:						debug("Gesture.STATE_UPDATE");						break;										case 3:						debug("Gesture.STATE_STOP");						break;										case 4:						debug("Gesture.TYPE_INVALID");						break;										case 5:						debug("Gesture.TYPE_SWIPE");												break;										case 6:						debug("Gesture.TYPE_CIRCLE");						break;										case 7:						debug("Gesture.TYPE_SCREEN_TAP");						break;										case 8:						debug("Gesture.TYPE_KEY_TAP");						break;														}			}					}				private function onLeapController(e:MuleEvent):void{			/*debug("onLeapController()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){																default:					debug("onLeapController()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);				break;							}		}				//*****Gets and Sets				public static function get instance():LeapController{return _instance;}				public function get frame():Frame{return _frame;}		public function get hands():Vector.<Hand>{return _hands;}		public function get fingers():Vector.<Finger>{return _fingers;}		public function get tools():Vector.<Tool>{return _tools;}		public function get pointables():Vector.<Pointable>{return _pointables;}		public function get gestures():Vector.<Gesture>{return _gestures;}				public function get active():Boolean{return _active;}		//*****Utility Functions				//**debug		private function debug(str:String):void{			utils.debug(NAME,str);		}				}//end class}//end packageclass LeapControllerLock{}