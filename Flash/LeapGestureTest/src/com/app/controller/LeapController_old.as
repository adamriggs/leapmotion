// com.adam.utils.LeapController// Adam Riggs//package com.app.controller{	import com.adam.events.MuleEvent;	import com.adam.utils.Utils;	import com.leapmotion.leap.CircleGesture;	import com.leapmotion.leap.Finger;	import com.leapmotion.leap.Frame;	import com.leapmotion.leap.Gesture;	import com.leapmotion.leap.Hand;	import com.leapmotion.leap.KeyTapGesture;	import com.leapmotion.leap.LeapMotion;	import com.leapmotion.leap.Pointable;	import com.leapmotion.leap.ScreenTapGesture;	import com.leapmotion.leap.SwipeGesture;	import com.leapmotion.leap.Tool;	import com.leapmotion.leap.Vector3;	import com.leapmotion.leap.events.LeapEvent;	import com.leapmotion.leap.util.LeapMath;		import flash.utils.getTimer;
		public class LeapController {				//vars		protected var _active:Boolean;		protected var _gestureNow:Number;		protected var _gestureStart:Number;		protected var _gestureStartBuffer:Number;		protected var _gestureDuration:Number;		protected var _gestureSwipe:Boolean;		protected var _swipeLeft:Boolean;		protected var _swipeRight:Boolean;						//objects		private var utils:Utils=Utils.instance;		private var _leap:LeapMotion;		protected var _frame:Frame;		protected var _hands:Vector.<Hand>;		protected var _fingers:Vector.<Finger>;		protected var _tools:Vector.<Tool>;		protected var _pointables:Vector.<Pointable>;		protected var _gestures:Vector.<Gesture>;				protected var _swipe:SwipeGesture;				//const		public const NAME:String="leapController";		public const RETURNTYPE:String=NAME;				public const SWIPERIGHT:String="swiperight";		public const SWIPELEFT:String="swipeleft";				/** Storage for the singleton instance. */		private static const _instance:LeapController = new LeapController(LeapControllerLock);				public function LeapController(lock:Class){			if (lock != LeapControllerLock)			{				throw new Error("Invalid LeapController access.  Use LeapController.instance instead.");			} else {				init();			}		}		//*****Initialization Routines				public function init():void{			debug("init()");						initVars();			initEvents();			initObjs();		}				private function initVars():void{			_active=false;			_gestureStartBuffer=.1;			_gestureDuration=.2		}				private function initEvents():void{			utils.em.listen(NAME, onLeapController);		}				private function initObjs():void{			_leap=new LeapMotion();			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_INIT, onInit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_CONNECTED, onConnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_DISCONNECTED, onDisconnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_EXIT, onExit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_FRAME, onFrame );			//			_leap.controller.enableGesture( Gesture.TYPE_CIRCLE );//			_leap.controller.enableGesture( Gesture.TYPE_KEY_TAP );//			_leap.controller.enableGesture( Gesture.TYPE_SCREEN_TAP );//			_leap.controller.enableGesture( Gesture.TYPE_SWIPE );			//			var ges:Gesture=new Gesture();//			var circle:CircleGesture=new CircleGesture();//			var key:KeyTapGesture=new KeyTapGesture();//			var screen:ScreenTapGesture=new ScreenTapGesture();//			var swipe:SwipeGesture=new SwipeGesture();		}		//*****Core Functionality		//		protected function getSwipeLeft():Boolean{//			//debug("getSwipeLeft()");//			if(((_gestureStart+_gestureStartBuffer+_gestureDuration)<_gestureNow) && _gestureSwipe && _swipeLeft){//				_swipeLeft=false;//				_swipeRight=false;//				_gestureSwipe=false;//				return true;//			} else {//				return false;//				//			}//			return false;//		}//		//		protected function getSwipeRight():Boolean{//			//debug("getSwipeRight()");//			if(((_gestureStart+_gestureStartBuffer+_gestureDuration)<_gestureNow) && _gestureSwipe && _swipeRight){//				_swipeRight=false;//				_swipeLeft=false;//				_gestureSwipe=false;//				return true;//			} else {//				return false;//				//			}//			return false;//		}				protected function getSwipeLeft():Boolean{			//_swipeLeft=false;			return _swipeLeft;		}				protected function getSwipeRight():Boolean{			//_swipeRight=false;			return _swipeRight;		}				protected function setSwipe(swipe:String):void{			debug("setSwipe()");			switch(swipe){								case SWIPELEFT:					_swipeLeft=true;					_swipeRight=false;					//debug("swipe left");					break;								case SWIPERIGHT:					_swipeLeft=false;					_swipeRight=true;					//debug("swipe right");					break;							}		}		//*****Event Handlers								private function onInit( event:LeapEvent ):void{			debug( "Initialized" );			_active=false;		}				private function onConnect( event:LeapEvent ):void{			debug( "Connected" );			_active=true;		}				private function onDisconnect( event:LeapEvent ):void{			debug( "Disconnected" );			_active=false;		}				private function onExit( event:LeapEvent ):void{			debug( "Exited" );			_active=false;		}				private function onFrame( event:LeapEvent ):void		{			//debug("onFrame");			// Get the most recent _frame and report some basic information			_frame = event.frame;			_hands = _frame.hands;			_fingers = _frame.fingers;			_tools=_frame.tools;			_pointables=_frame.pointables;			_gestures=_frame._gestures;						for each(var finger:Finger in _frame.fingers){				if(finger.tipVelocity.x>100 || finger.tipVelocity.x<100){					debug("finger.tipVelocity.x=="+finger.tipVelocity.x);				}				if(finger.tipVelocity.y>100 || finger.tipVelocity.y<100){					debug("finger.tipVelocity.y=="+finger.tipVelocity.y);				}				if(finger.tipVelocity.z>100 || finger.tipVelocity.z<100){					debug("finger.tipVelocity.z=="+finger.tipVelocity.z);				}			}									for each(var hand:Hand in event.frame.hands)			{				//debug("palmVelocity.x=="+hand.palmVelocity.x);				if(hand.fingers.length > 0)				{					//debug("palmVelocity.x=="+hand.palmVelocity.x);					if(hand.palmVelocity.x > 100)					{						//debug("right");						setSwipe(SWIPERIGHT);					}					else if(hand.palmVelocity.x < -100)					{						//debug("left");						setSwipe(SWIPELEFT);					}else {						_swipeLeft=false;						_swipeRight=false;					}				} else {					_swipeLeft=false;					_swipeRight=false;				}			}						if(_gestures.length>0){								switch(_gestures[0].type){										case 0:						debug("Gesture.STATE_INVALID");						break;										case 1:						debug("Gesture.STATE_START");						break;										case 2:						debug("Gesture.STATE_UPDATE");						break;										case 3:						debug("Gesture.STATE_STOP");						break;										case 4:						debug("Gesture.TYPE_INVALID");						break;										case 5:						debug("Gesture.TYPE_SWIPE");						//						_swipe=_gestures[0] as SwipeGesture;//						//						if(_gestureSwipe){//							_gestureNow=getTimer();//							if(_gestureNow>(_gestureStart+_gestureStartBuffer)){//								if(_swipe.direction.x>0){//									//debug("swipe right");//									_swipeLeft=true;//									_swipeRight=false;//								} else {//									//debug("swipe left");//									_swipeRight=true;//									_swipeLeft=false;//								}//							}//						}//						//						if(!_gestureSwipe){//							//debug("!_gestureSwipe");//							_gestureSwipe=true;//							_gestureStart=getTimer();//						}//						debug("_gestures[0].durationSeconds=="+_gestures[0].durationSeconds);//						var ges:SwipeGesture=_gestures[0] as SwipeGesture;//						debug("ges.direction.x=="+ges.direction.x);//						debug("ges.direction.y=="+ges.direction.y);//						debug("ges.direction.z=="+ges.direction.z);						//debug("*****");						break;										case 6:						debug("Gesture.TYPE_CIRCLE");						break;										case 7:						debug("Gesture.TYPE_SCREEN_TAP");						break;										case 8:						debug("Gesture.TYPE_KEY_TAP");						break;														}			} else {				//debug("*****");//				_gestureSwipe=false;//				_swipeLeft=false;//				_swipeRight=false;			}					}				private function onLeapController(e:MuleEvent):void{			/*debug("onLeapController()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){																default:					debug("onLeapController()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);				break;							}		}				//*****Gets and Sets				public static function get instance():LeapController{return _instance;}				public function get frame():Frame{return _frame;}		public function get hands():Vector.<Hand>{return _hands;}		public function get fingers():Vector.<Finger>{return _fingers;}		public function get tools():Vector.<Tool>{return _tools;}		public function get pointables():Vector.<Pointable>{return _pointables;}				public function get gestures():Vector.<Gesture>{return _gestures;}		public function get swipeLeft():Boolean{return getSwipeLeft();}		public function get swipeRight():Boolean{return getSwipeRight();}				public function get active():Boolean{return _active;}		//*****Utility Functions				//**debug		private function debug(str:String):void{			utils.debug(NAME,str);		}				}//end class}//end packageclass LeapControllerLock{}