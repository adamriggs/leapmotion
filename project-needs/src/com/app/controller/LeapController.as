// com.adam.utils.LeapController// Adam Riggs//package com.app.controller{	import com.adam.events.MuleEvent;	import com.adam.utils.Utils;	import com.greensock.TweenLite;	import com.leapmotion.leap.Finger;	import com.leapmotion.leap.Frame;	import com.leapmotion.leap.Hand;	import com.leapmotion.leap.LeapMotion;	import com.leapmotion.leap.Vector3;	import com.leapmotion.leap.events.LeapEvent;	import com.leapmotion.leap.util.LeapMath;		public class LeapController {				//vars		private var _left:Boolean;		private var _right:Boolean;		private var _up:Boolean;		private var _down:Boolean;		private var _fire:Boolean;				//objects		private var utils:Utils=Utils.instance;		private var _leap:LeapMotion;				//const		public const NAME:String="leapController";		public const RETURNTYPE:String=NAME;				/** Storage for the singleton instance. */		private static const _instance:LeapController = new LeapController(LeapControllerLock);				public function LeapController(lock:Class){			if (lock != LeapControllerLock)			{				throw new Error("Invalid LeapController access.  Use LeapController.instance instead.");			} else {				init();			}		}		//*****Initialization Routines				public function init():void{			debug("init()");						initVars();			initEvents();			initObjs();		}				private function initVars():void{					}				private function initEvents():void{			utils.em.listen(NAME, onLeapController);		}				private function initObjs():void{			_leap=new LeapMotion();			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_INIT, onInit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_CONNECTED, onConnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_DISCONNECTED, onDisconnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_EXIT, onExit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_FRAME, onFrame );		}		//*****Core Functionality						//*****Event Handlers								private function onInit( event:LeapEvent ):void{			debug( "Initialized" );		}				private function onConnect( event:LeapEvent ):void{			debug( "Connected" );		}				private function onDisconnect( event:LeapEvent ):void{			debug( "Disconnected" );		}				private function onExit( event:LeapEvent ):void{			debug( "Exited" );		}				private function onFrame( event:LeapEvent ):void		{			// Get the most recent frame and report some basic information			var frame:Frame = event.frame;			debug( "Frame id: " + frame.id + ", timestamp: " + frame.timestamp + ", hands: " + frame.hands.length + ", fingers: " + frame.fingers.length + ", tools: " + frame.tools.length );						if ( frame.hands.length > 0 )			{				// Get the first hand				var hand:Hand = frame.hands[ 0 ];								// Check if the hand has any fingers				var fingers:Vector.<Finger> = hand.fingers;				if ( !fingers.length == 0 )				{					// Calculate the hand's average finger tip position					var avgPos:Vector3 = Vector3.zero();					for each ( var finger:Finger in fingers )					avgPos = avgPos.plus( finger.tipPosition );										avgPos = avgPos.divide( fingers.length );					//debug( "Hand has " + fingers.length + " fingers, average finger tip position: " + avgPos );				}								// Get the hand's sphere radius and palm position				debug( "Hand sphere radius: " + hand.sphereRadius + " mm, palm position: " + hand.palmPosition );								// Get the hand's normal vector and direction				var normal:Vector3 = hand.palmNormal;				var direction:Vector3 = hand.direction;								// Calculate the hand's pitch, roll, and yaw angles				debug( "Hand pitch: " + LeapMath.toDegrees( direction.pitch ) + " degrees, " + "roll: " + LeapMath.toDegrees( normal.roll ) + " degrees, " + "yaw: " + LeapMath.toDegrees( direction.yaw ) + " degrees\n" );								if(LeapMath.toDegrees( direction.pitch )>20){_up=true;}else{_up=false;}				if(LeapMath.toDegrees( direction.pitch )<-20){_down=true;}else{_down=false;}				if(LeapMath.toDegrees( normal.roll )>15){_left=true;}else{_left=false;}				if(LeapMath.toDegrees( normal.roll )<-15){_right=true;}else{_right=false;}								if(frame.hands.length==2){_fire=true;}else{_fire=false;}						} else {				_up=false;				_down=false;				_right=false;				_left=false;				_fire=false;			}		}				private function onLeapController(e:MuleEvent):void{			/*debug("onLeapController()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){																default:					debug("onLeapController()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);				break;							}		}				//*****Gets and Sets				public static function get instance():LeapController{return _instance;}				public function get left():Boolean{return _left;}		public function get right():Boolean{return _right;}		public function get up():Boolean{return _up;}		public function get down():Boolean{return _down;}		public function get fire():Boolean{return _fire;}		//*****Utility Functions				//**debug		private function debug(str:String):void{			utils.debug(NAME,str);		}				}//end class}//end packageclass LeapControllerLock{}