// com.adam.utils.LeapController// Adam Riggs//package com.app.controller{	import com.adam.events.MuleEvent;	import com.adam.utils.Utils;	import com.leapmotion.leap.CircleGesture;	import com.leapmotion.leap.Finger;	import com.leapmotion.leap.Frame;	import com.leapmotion.leap.Gesture;	import com.leapmotion.leap.Hand;	import com.leapmotion.leap.KeyTapGesture;	import com.leapmotion.leap.LeapMotion;	import com.leapmotion.leap.Pointable;	import com.leapmotion.leap.ScreenTapGesture;	import com.leapmotion.leap.SwipeGesture;	import com.leapmotion.leap.Tool;	import com.leapmotion.leap.Vector3;	import com.leapmotion.leap.events.LeapEvent;	import com.leapmotion.leap.util.LeapMath;		import flash.utils.getTimer;
		public class LeapController {				//vars		protected var _active:Boolean;		protected var _gestureNow:Number;		protected var _gestureStart:Number;		protected var _gestureStartBuffer:Number;		protected var _gestureDuration:Number;		protected var _gestureSwipe:Boolean;		protected var _swipeLeft:Boolean;		protected var _swipeRight:Boolean;						//objects		private var utils:Utils=Utils.instance;		private var _leap:LeapMotion;		protected var _frame:Frame;		protected var _hands:Vector.<Hand>;		protected var _fingers:Vector.<Finger>;		protected var _tools:Vector.<Tool>;		protected var _pointables:Vector.<Pointable>;		protected var _gestures:Vector.<Gesture>;				protected var _swipe:SwipeGesture;				//const		public const NAME:String="leapController";		public const RETURNTYPE:String=NAME;				/** Storage for the singleton instance. */		private static const _instance:LeapController = new LeapController(LeapControllerLock);				public function LeapController(lock:Class){			if (lock != LeapControllerLock)			{				throw new Error("Invalid LeapController access.  Use LeapController.instance instead.");			} else {				init();			}		}		//*****Initialization Routines				public function init():void{			debug("init()");						initVars();			initEvents();			initObjs();		}				private function initVars():void{			_active=false;			_gestureStartBuffer=.1;			_gestureDuration=.5;		}				private function initEvents():void{			utils.em.listen(NAME, onLeapController);		}				private function initObjs():void{			_leap=new LeapMotion();			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_INIT, onInit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_CONNECTED, onConnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_DISCONNECTED, onDisconnect );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_EXIT, onExit );			_leap.controller.addEventListener( LeapEvent.LEAPMOTION_FRAME, onFrame );						_leap.controller.enableGesture( Gesture.TYPE_CIRCLE );			_leap.controller.enableGesture( Gesture.TYPE_KEY_TAP );			_leap.controller.enableGesture( Gesture.TYPE_SCREEN_TAP );			_leap.controller.enableGesture( Gesture.TYPE_SWIPE );			//			var ges:Gesture=new Gesture();//			var circle:CircleGesture=new CircleGesture();//			var key:KeyTapGesture=new KeyTapGesture();//			var screen:ScreenTapGesture=new ScreenTapGesture();//			var swipe:SwipeGesture=new SwipeGesture();		}		//*****Core Functionality				protected function getSwipeLeft():Boolean{			//debug("getSwipeLeft()");			if(((_gestureStart+_gestureStartBuffer+_gestureDuration)<_gestureNow) && _gestureSwipe && _swipeLeft){				_swipeLeft=false;				_swipeRight=false;				_gestureSwipe=false;				return true;			} else {				return false;							}			return false;		}				protected function getSwipeRight():Boolean{			//debug("getSwipeRight()");			if(((_gestureStart+_gestureStartBuffer+_gestureDuration)<_gestureNow) && _gestureSwipe && _swipeRight){				_swipeRight=false;				_swipeLeft=false;				_gestureSwipe=false;				return true;			} else {				return false;							}			return false;		}		//*****Event Handlers								private function onInit( event:LeapEvent ):void{			debug( "Initialized" );			_active=false;		}				private function onConnect( event:LeapEvent ):void{			debug( "Connected" );			_active=true;		}				private function onDisconnect( event:LeapEvent ):void{			debug( "Disconnected" );			_active=false;		}				private function onExit( event:LeapEvent ):void{			debug( "Exited" );			_active=false;		}				private function onFrame( event:LeapEvent ):void		{			//debug("onFrame");			// Get the most recent _frame and report some basic information			_frame = event.frame;			_hands = _frame.hands;			_fingers = _frame.fingers;			_tools=_frame.tools;			_pointables=_frame.pointables;			_gestures=_frame._gestures;						if(_gestures.length>0){								switch(_gestures[0].type){										case 0:						debug("Gesture.STATE_INVALID");						break;										case 1:						debug("Gesture.STATE_START");						break;										case 2:						debug("Gesture.STATE_UPDATE");						break;										case 3:						debug("Gesture.STATE_STOP");						break;										case 4:						debug("Gesture.TYPE_INVALID");						break;										case 5:						//debug("Gesture.TYPE_SWIPE");												_swipe=_gestures[0] as SwipeGesture;												if(_gestureSwipe){							_gestureNow=getTimer();							if(_gestureNow>(_gestureStart+_gestureStartBuffer)){								if(_swipe.direction.x>0){									debug("swipe right");									_swipeLeft=true;									_swipeRight=false;								} else {									debug("swipe left");									_swipeRight=true;									_swipeLeft=false;								}							}						}												if(!_gestureSwipe){							debug("!_gestureSwipe");							_gestureSwipe=true;							_gestureStart=getTimer();						}//						debug("_gestures[0].durationSeconds=="+_gestures[0].durationSeconds);//						var ges:SwipeGesture=_gestures[0] as SwipeGesture;//						debug("ges.direction.x=="+ges.direction.x);//						debug("ges.direction.y=="+ges.direction.y);//						debug("ges.direction.z=="+ges.direction.z);						debug("*****");						break;										case 6:						debug("Gesture.TYPE_CIRCLE");						break;										case 7:						debug("Gesture.TYPE_SCREEN_TAP");						break;										case 8:						debug("Gesture.TYPE_KEY_TAP");						break;														}			} else {				//debug("*****");				_gestureSwipe=false;				_swipeLeft=false;				_swipeRight=false;			}					}				private function onLeapController(e:MuleEvent):void{			/*debug("onLeapController()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){																default:					debug("onLeapController()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);				break;							}		}				//*****Gets and Sets				public static function get instance():LeapController{return _instance;}				public function get frame():Frame{return _frame;}		public function get hands():Vector.<Hand>{return _hands;}		public function get fingers():Vector.<Finger>{return _fingers;}		public function get tools():Vector.<Tool>{return _tools;}		public function get pointables():Vector.<Pointable>{return _pointables;}				public function get gestures():Vector.<Gesture>{return _gestures;}		public function get swipeLeft():Boolean{return getSwipeLeft();}		public function get swipeRight():Boolean{return getSwipeRight();}				public function get active():Boolean{return _active;}		//*****Utility Functions				//**debug		private function debug(str:String):void{			utils.debug(NAME,str);		}				}//end class}//end packageclass LeapControllerLock{}